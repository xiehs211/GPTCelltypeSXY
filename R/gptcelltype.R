#' Cell type annotation with OpenAI GPT models
#'
#' Cell type annotation with OpenAI GPT models
#'
#' Annotate cell types by OpenAI GPT models in a Seurat pipeline or with a custom gene list. If used in a Seurat pipeline, Seurat FindAllMarkers() function needs to be run first and the differential gene table generated by Seurat will serve as the input. If the input is a custom list of genes, one cell type is identified for each element in the list.  Note: system environment should have variable OPENAI_API_KEY = 'your_api_key' or ''. The OpenAI key can be obtained from https://platform.openai.com/account/api-keys. If '', then output the prompt itself. If an actual key is provided, then the output will be the celltype annotations from the GPT model specified by the user. 
#' 
#' @param input Either the differential gene table returned by Seurat FindAllMarkers() function, or a list of genes.
#' @param tissuename Optional input of tissue name.
#' @param openai_key The OpenAI key obtained from https://platform.openai.com/account/api-keys The default is NA, which will resulting outputing the prompt itself. If an actual key is provided, then the output will be the celltype annotations from the GPT model specified by the user. 
#' @param model A valid GPT-4 or GPT-3.5 model name list on https://platform.openai.com/docs/models. Default is 'gpt-4-32k'.
#' @param topgenenumber Number of top differential genes to be used if input is Seurat differential genes.
#' @import apiSXY
#' @export
#' @return A vector of cell types when the user provide openai_key or the prompt itself when openai_key = NA (default)
#' @author Wenpin Hou <wh2526@@cumc.columbia.edu>, Zhicheng Ji <zhicheng.ji@@duke.edu>
#' @examples 
#' # Gene list as input, OPENAI_API_KEY = NA (default)
#' Sys.setenv(OPENAI_API_KEY = '')
#' print(Sys.getenv('OPENAI_API_KEY'))  
#' gptcelltype(input = list(gs1=c('CD4,CD3D'),gs2='CD14'), tissuename=NULL, model='gpt-4', topgenenumber = 10) 
#' # Seurat object as input, openai_key = NA (default)
#' #You have to install Seurat package first to run this example
#' library(Seurat)
#' data("pbmc_small")
#' all.markers <- FindAllMarkers(object = pbmc_small)
#' Sys.setenv(OPENAI_API_KEY = '')
#' print(Sys.getenv('OPENAI_API_KEY'))  
#' prompt <- gptcelltype(all.markers, tissuename='human PBMC')
#' return(prompt)

gptcelltype <- function(input, tissuename=NULL, model='gpt-4', topgenenumber = 10) {
  message("you are using GPTCelltype - powered by yinyunapi")
  OPENAI_API_KEY <- Sys.getenv("OPENAI_API_KEY")
  if (OPENAI_API_KEY == "") {
    print("请设置你的OPENAI_API_KEY!")
    API.flag <- 0
  } else {
    API.flag <- 1
  }
  
  if (class(input)=='list') {
    input <- sapply(input,paste,collapse=',')
  } else {
    input <- input[input$avg_log2FC > 0,,drop=FALSE]
    input <- tapply(input$gene,list(input$cluster),function(i) paste0(i[1:topgenenumber],collapse=','))
  }
  
  if (!API.flag){
   message = paste0('Identify cell types of ',tissuename,' cells using the following markers separately for each\n row. Only provide the cell type name. Do not show numbers before the name.\n Some can be a mixture of multiple cell types. ',  "\n", paste0(names(input), ':',unlist(input),collapse = "\n"))
    
    return(message)
    
  } else {
    print("Note: OpenAI API key found: returning the cell type annotations.")
    cutnum <- ceiling(length(input)/30)
    if (cutnum > 1) {
      cid <- as.numeric(cut(1:length(input),cutnum))	
    } else {
      cid <- rep(1,length(input))
    }
    
    max_attempts <- 3

    system_prompt <- paste0(
      "You are a bioinformatics assistant. ",
      "Return ONLY valid JSON like {\"",
      paste(names(input), collapse = ":\"placeholder\", \""),
      "\":\"placeholder\"}. ",
      "Keys must match provided cluster names and values must be cell type names. ",
      "No explanations, no additional text."
    )

    allres <- sapply(1:cutnum,function(i) {
      id <- which(cid==i)
      flag <- 0
      attempts <- 0
      last_error <- NULL
      user_prompt <- paste0(
        "Identify cell types of ",tissuename," cells using the following markers separately for each\n row. ",
        "Return JSON with the cluster names as keys and the cell type name as value. ",
        "Only output JSON, nothing else.\n",
        paste0(names(input)[id], ":",input[id],collapse = "\n")
      )
      while (flag == 0) {
        attempts <- attempts + 1
        k <- tryCatch({
          apiSXY::create_chat_completion(
            model = model,
            messages = list(
              list("role" = "system", "content" = system_prompt),
              list("role" = "user", "content" = user_prompt)
            )
          )
        }, error = function(e) {
          last_error <<- e
          NULL
        })
        if (is.null(k)) {
          if (attempts >= max_attempts) {
            stop(sprintf('API请求连续失败（cluster: %s）: %s', paste(names(input)[id], collapse = ', '), conditionMessage(last_error)))
          }
          message(sprintf('API请求失败，第%d/%d次重试: %s', attempts, max_attempts, conditionMessage(last_error)))
          Sys.sleep(2 ^ (attempts - 1))
          next
        }
        content_text <- k$choices[,'message.content']
        cleaned_text <- gsub('```[a-zA-Z]*', '', content_text)
        cleaned_text <- gsub('```', '', cleaned_text, fixed = TRUE)
        parsed_json <- tryCatch({
          jsonlite::fromJSON(cleaned_text)
        }, error = function(e) NULL)
        if (!is.null(parsed_json) && all(names(input)[id] %in% names(parsed_json))) {
          res <- as.character(parsed_json[names(input)[id]])
          flag <- 1
          next
        }
        res <- strsplit(content_text,'\n')[[1]]
        res <- trimws(res)
        res <- res[nzchar(res)]
        if (length(res) >= length(id)) {
          res <- tail(res, length(id))
          flag <- 1
        } else {
          if (attempts >= max_attempts) {
            stop(sprintf('API返回的有效行数(%d)少于所需(%d)。最后一次响应：%s', length(res), length(id), content_text))
          }
          message(sprintf('API返回行数(%d)与预期(%d)不符，第%d/%d次重试...', length(res), length(id), attempts, max_attempts))
          Sys.sleep(1)
        }
      }
      names(res) <- names(input)[id]
      res
    },simplify = F) 

    print('Note: It is always recommended to check the results returned by GPT-4 in case of\n AI hallucination, before going to down-stream analysis.')
    return(gsub(',$','',unlist(allres)))
  }
  
}






